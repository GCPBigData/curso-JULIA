

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Types &mdash; documentación de Julia Language - 0.3-dev</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  

  
    <link rel="stylesheet" href="https://media.readthedocs.org/css/badge_only.css" type="text/css" />
  
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/julia.css" type="text/css" />
  
    <link rel="top" title="documentación de Julia Language - 0.3-dev" href="../index.html"/>
        <link rel="up" title="El Manual de Julia" href="index.html"/>
        <link rel="next" title="Methods" href="methods.html"/>
        <link rel="prev" title="Variables and Scoping" href="variables-and-scoping.html"/>
 
<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://julia-es-la.readthedocs.org/es/latest/manual/types.html" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "julia-es-la",
    version: "latest",
    language: "es",
    page: "manual/types",
    theme: "julia",
    docroot: "/",
    source_suffix: ".rst",
    api_host: "https://readthedocs.org"
  }
  // Old variables
  var doc_version = "latest";
  var doc_slug = "julia-es-la";
  var page_name = "manual/types";
  var html_theme = "julia";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../index.html" class="fa fa-home"> Julia Language</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">El Manual de Julia</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introducción</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-started.html">Comenzando</a></li>
<li class="toctree-l2"><a class="reference internal" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html">Mathematical Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html">Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html">Control Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html">Variables and Scoping</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion-and-promotion.html">Conversion and Promotion</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html">Metaprogramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html">Arreglos</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html#sparse-matrices">Sparse Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html">Parallel Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html">Running External Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html">Julia Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html">Performance Tips</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/index.html">Libreria estandar de Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../stdlib/index.html#built-ins">Built-ins</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stdlib/index.html#built-in-modules">Built-in Modules</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../packages/packagelist.html">Paquetes Disponibles (en inglés)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id1">ArgParse</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id2">Benchmark</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id3">BinDeps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id4">BioSeq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id5">BloomFilters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id7">Cairo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id8">Calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id10">Calendar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id11">Catalan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id12">Clang</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id13">Clp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id14">Clustering</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id16">Codecs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id17">CoinMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id19">Color</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id21">Compose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id23">ContinuedFractions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id25">Cpp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id26">Cubature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id27">Curl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id28">DICOM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id30">DataFrames</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id31">DataStructures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id32">Debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id33">DecisionTree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id34">Devectorize</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id36">DictViews</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id37">DimensionalityReduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id39">Distance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id41">Distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id42">Elliptic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id44">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id46">FITSIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id48">FactCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id49">FastaRead</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id51">FileFind</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id53">GLFW</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id54">GLM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id56">GLPK</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id58">GLUT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id59">GSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id60">GZip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id61">Gadfly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id63">Gaston</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id64">GetC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id66">GoogleCharts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id67">Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id69">Grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id71">Gtk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id72">Gurobi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id74">HDF5</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id76">HDFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id78">HTTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id79">Hadamard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id81">HypothesisTests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id82">ICU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id84">Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id86">ImmutableArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id87">IniFile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id89">Iterators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id91">Ito</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id92">JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id94">JudyDicts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id95">JuliaWebRepl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id97">Jyacas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id99">KLDivergence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id101">LM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id103">Languages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id105">LazySequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id107">LinProgGLPK</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id109">Loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id111">MAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id113">MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id115">MCMC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id116">MLBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id118">MarketTechnicals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id119">MathProg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id120">MathProgBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id122">Meshes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id124">MixedModels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id125">Monads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id126">Mongo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id127">Mongrel2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id129">Mustache</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id131">NHST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id133">NLopt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id135">Named</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id137">ODBC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id138">ODE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id140">OpenGL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id142">OpenSSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id144">Optim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id146">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id148">PLX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id150">PatternDispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id152">Polynomial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id154">Profile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id156">ProjectTemplate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id158">PyCall</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id160">QuickCheck</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id162">RDatasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id164">RNGTest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id165">RandomMatrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id167">Resampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id169">Rif</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id170">Rmath</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id172">SDE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id173">SDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id175">SemidefiniteProgramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id177">SimJulia</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id178">Sims</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id179">Stats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id181">StrPack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id183">Sundials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id185">SymbolicLP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id187">TOML</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id188">TextAnalysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id190">TextWrap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id192">TimeModels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id194">TimeSeries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id196">Tk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id198">TkExtras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id200">TopicModels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id201">TradingInstrument</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id203">Trie</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id205">UTF16</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id207">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id209">WAV</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id210">Winston</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id212">ZMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id214">Zlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../packages/packagelist.html#id216">kNN</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Julia Language</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">El Manual de Julia</a> &raquo;</li>
      
    <li>Types</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="https://github.com/lbenitesanchez/julia-doc-es-la/blob/master/manual/types.rst" class="fa fa-github"> Edit on GitHub</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="types">
<span id="man-types"></span><h1>Types<a class="headerlink" href="#types" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Type systems have traditionally fallen into two quite different camps:
static type systems, where every program expression must have a type
computable before the execution of the program, and dynamic type
systems, where nothing is known about types until run time, when the
actual values manipulated by the program are available. Object
orientation allows some flexibility in statically typed languages by
letting code be written without the precise types of values being known
at compile time. The ability to write code that can operate on different
types is called polymorphism. All code in classic dynamically typed
languages is polymorphic: only by explicitly checking types, or when
objects fail to support operations at run-time, are the types of any
values ever restricted.</p>
<p>Julia&#8217;s type system is dynamic, but gains some of the advantages of
static type systems by making it possible to indicate that certain
values are of specific types. This can be of great assistance in
generating efficient code, but even more significantly, it allows method
dispatch on the types of function arguments to be deeply integrated with
the language. Method dispatch is explored in detail in
<a class="reference internal" href="methods.html#man-methods"><em>Methods</em></a>, but is rooted in the type system presented
here.</p>
<p>The default behavior in Julia when types are omitted is to allow values
to be of any type. Thus, one can write many useful Julia programs
without ever explicitly using types. When additional expressiveness is
needed, however, it is easy to gradually introduce explicit type
annotations into previously &#8220;untyped&#8221; code. Doing so will typically
increase both the performance and robustness of these systems, and
perhaps somewhat counterintuitively, often significantly simplify them.</p>
<p>Describing Julia in the lingo of <a class="reference external" href="http://en.wikipedia.org/wiki/Type_system">type
systems</a>, it is: dynamic,
nominative, parametric and dependent. Generic types can be parameterized
by other types and by integers, and the hierarchical relationships
between types are explicitly declared, rather than implied by compatible
structure. One particularly distinctive feature of Julia&#8217;s type system
is that concrete types may not subtype each other: all concrete types
are final and may only have abstract types as their supertypes. While
this might at first seem unduly restrictive, it has many beneficial
consequences with surprisingly few drawbacks. It turns out that being
able to inherit behavior is much more important than being able to
inherit structure, and inheriting both causes significant difficulties
in traditional object-oriented languages. Other high-level aspects of
Julia&#8217;s type system that should be mentioned up front are:</p>
<ul class="simple">
<li>There is no division between object and non-object values: all values
in Julia are true objects having a type that belongs to a single,
fully connected type graph, all nodes of which are equally
first-class as types.</li>
<li>There is no meaningful concept of a &#8220;compile-time type&#8221;: the only
type a value has is its actual type when the program is running. This
is called a &#8220;run-time type&#8221; in object-oriented languages where the
combination of static compilation with polymorphism makes this
distinction significant.</li>
<li>Only values, not variables, have types — variables are simply names
bound to values.</li>
<li>Both abstract and concrete types can be paramaterized by other types
and by integers. Type parameters may be completely omitted when they
do not need to be explicitly referenced or restricted.</li>
</ul>
<p>Julia&#8217;s type system is designed to be powerful and expressive, yet
clear, intuitive and unobtrusive. Many Julia programmers may never feel
the need to write code that explicitly uses types. Some kinds of
programming, however, become clearer, simpler, faster and more robust
with declared types.</p>
<div class="sidebar"><p>A Note On Capitalization. There is no semantic significance to
capitalization of names in Julia, unlike, for example, Ruby, where
identifiers beginning with an uppercase letter (including type names)
are constants. By convention, however, the first letter of each word in
a Julia type name begins with a capital letter and underscores are not
used to separate words. Variables, on the other hand, are conventionally
given lowercase names, with word separation indicated by underscores
(&#8220;_&#8221;). In numerical code it is not uncommon to use single-letter
uppercase variable names, especially for matrices. Since types rarely
have single-letter names, this does not generally cause confusion,
although type parameter placeholders (see below) also typically use
single-letter uppercase names like T or S.</p>
</div><div class="section" id="type-declarations">
<h2>Type Declarations<a class="headerlink" href="#type-declarations" title="Enlazar permanentemente con este título">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">::</span></tt> operator can be used to attach type annotations to
expressions and variables in programs. There are two primary reasons to
do this:</p>
<ol class="arabic simple">
<li>As an assertion to help confirm that your program works the way you
expect,</li>
<li>To provide extra type information to the compiler, which can then
improve performance in many cases</li>
</ol>
<p>The <tt class="docutils literal"><span class="pre">::</span></tt> operator is read as &#8220;is an instance of&#8221; and can be used
anywhere to assert that the value of the expression on the left is an
instance of the type on the right. When the type on the right is
concrete, the value on the left must have that type as its
implementation —&nbsp;recall that all concrete types are final, so no
implementation is a subtype of any other. When the type is abstract, it
suffices for the value to be implemented by a concrete type that is a
subtype of the abstract type. If the type assertion is not true, an
exception is thrown, otherwise, the left-hand value is returned:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)::</span><span class="n">FloatingPoint</span>
<span class="k">type</span><span class="nc"> error</span><span class="p">:</span> <span class="n">typeassert</span><span class="p">:</span> <span class="n">expected</span> <span class="n">FloatingPoint</span><span class="p">,</span> <span class="n">got</span> <span class="kt">Int64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)::</span><span class="kt">Int</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>This allows a type assertion to be attached to any expression in-place.</p>
<p>When attached to a variable, the <tt class="docutils literal"><span class="pre">::</span></tt> operator means something a bit
different: it declares the variable to always have the specified type,
like a type declaration in a statically-typed language such as C. Every
value assigned to the variable will be converted to the declared type
using the <tt class="docutils literal"><span class="pre">convert</span></tt> function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span><span class="nf"> foo</span><span class="p">()</span>
         <span class="n">x</span><span class="p">::</span><span class="kt">Int8</span> <span class="o">=</span> <span class="mi">1000</span>
         <span class="n">x</span>
       <span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span>
<span class="o">-</span><span class="mi">24</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="kt">Int8</span>
</pre></div>
</div>
<p>This feature is useful for avoiding performance &#8220;gotchas&#8221; that could
occur if one of the assignments to a variable changed its type
unexpectedly.</p>
<p>The &#8220;declaration&#8221; behavior only occurs in specific contexts:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">x</span><span class="p">::</span><span class="kt">Int8</span>        <span class="c"># a variable by itself</span>
<span class="kd">local</span> <span class="n">x</span><span class="p">::</span><span class="kt">Int8</span>  <span class="c"># in a local declaration</span>
<span class="n">x</span><span class="p">::</span><span class="kt">Int8</span> <span class="o">=</span> <span class="mi">10</span>   <span class="c"># as the left-hand side of an assignment</span>
</pre></div>
</div>
<p>In value contexts, such as <tt class="docutils literal"><span class="pre">f(x::Int8)</span></tt>, the <tt class="docutils literal"><span class="pre">::</span></tt> is a type
assertion again and not a declaration. Note that these declarations
cannot be used in global scope currently, in the REPL, since julia
does not yet have constant-type globals.</p>
</div>
<div class="section" id="abstract-types">
<span id="man-abstract-types"></span><h2>Abstract Types<a class="headerlink" href="#abstract-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Abstract types cannot be instantiated, and serve only as nodes in the
type graph, thereby describing sets of related concrete types: those
concrete types which are their descendants. We begin with abstract types
even though they have no instantiation because they are the backbone of
the type system: they form the conceptual hierarchy which makes Julia&#8217;s
type system more than just a collection of object implementations.</p>
<p>Recall that in <a class="reference internal" href="integers-and-floating-point-numbers.html#man-integers-and-floating-point-numbers"><em>Integers and Floating-Point Numbers</em></a>, we introduced a
variety of concrete types of numeric values: <tt class="docutils literal"><span class="pre">Int8</span></tt>, <tt class="docutils literal"><span class="pre">Uint8</span></tt>,
<tt class="docutils literal"><span class="pre">Int16</span></tt>, <tt class="docutils literal"><span class="pre">Uint16</span></tt>, <tt class="docutils literal"><span class="pre">Int32</span></tt>, <tt class="docutils literal"><span class="pre">Uint32</span></tt>, <tt class="docutils literal"><span class="pre">Int64</span></tt>, <tt class="docutils literal"><span class="pre">Uint64</span></tt>,
<tt class="docutils literal"><span class="pre">Float32</span></tt>, and <tt class="docutils literal"><span class="pre">Float64</span></tt>. These are all <a class="reference external" href="#Bits+Types">bits types</a>,
which we will discuss in the next section. Although they have different
representation sizes, <tt class="docutils literal"><span class="pre">Int8</span></tt>, <tt class="docutils literal"><span class="pre">Int16</span></tt>, <tt class="docutils literal"><span class="pre">Int32</span></tt> and <tt class="docutils literal"><span class="pre">Int64</span></tt> all
have in common that they are signed integer types. Likewise <tt class="docutils literal"><span class="pre">Uint8</span></tt>,
<tt class="docutils literal"><span class="pre">Uint16</span></tt>, <tt class="docutils literal"><span class="pre">Uint32</span></tt> and <tt class="docutils literal"><span class="pre">Uint64</span></tt> are all unsigned integer types,
while <tt class="docutils literal"><span class="pre">Float32</span></tt> and <tt class="docutils literal"><span class="pre">Float64</span></tt> are distinct in being floating-point
types rather than integers. It is common for a piece of code to make
sense, for example, only if its arguments are some kind of integer, but
not really depend on what particular <em>kind</em> of integer, as long as the
appropriate low-level implementations of integer operations are used.
For example, the greatest common denominator algorithm works for all
kinds of integers, but will not work for floating-point numbers.
Abstract types allow the construction of a hierarchy of types,
providing&nbsp;a context into which concrete types can fit. This allows you,
for example, to easily program to any type that is an integer, without
restricting an algorithm to a specific type of integer.</p>
<p>Abstract types are declared using the <tt class="docutils literal"><span class="pre">abstract</span></tt> keyword. The general
syntaxes for declaring an abstract type are:</p>
<div class="highlight-julia"><div class="highlight"><pre>abstract «name»
abstract «name» &lt;: «supertype»
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">abstract</span></tt> keyword introduces a new abstract type, whose name is
given by <tt class="docutils literal"><span class="pre">«name»</span></tt>. This name can be optionally followed by <tt class="docutils literal"><span class="pre">&lt;:</span></tt> and
an already-existing type, indicating that the newly declared abstract
type is a subtype of this &#8220;parent&#8221; type.</p>
<p>When no supertype is given, the default supertype is <tt class="docutils literal"><span class="pre">Any</span></tt> — a
predefined abstract type that all objects are instances of and all types
are subtypes of. In type theory, <tt class="docutils literal"><span class="pre">Any</span></tt> is commonly called &#8220;top&#8221;
because it is at the apex of the type graph. Julia also has a predefined
abstract &#8220;bottom&#8221; type, at the nadir of the type graph, which is called
<tt class="docutils literal"><span class="pre">None</span></tt>. It is the exact opposite of <tt class="docutils literal"><span class="pre">Any</span></tt>: no object is an instance
of <tt class="docutils literal"><span class="pre">None</span></tt> and all types are supertypes of <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>As a specific example, let&#8217;s consider a subset of the abstract types
that make up Julia&#8217;s numerical hierarchy:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">abstract</span><span class="nc"> Number</span>
<span class="k">abstract</span><span class="nc"> Real</span>     <span class="o">&lt;:</span> <span class="n">Number</span>
<span class="k">abstract</span><span class="nc"> FloatingPoint</span> <span class="o">&lt;:</span> <span class="n">Real</span>
<span class="k">abstract</span><span class="nc"> Integer</span>  <span class="o">&lt;:</span> <span class="n">Real</span>
<span class="k">abstract</span><span class="nc"> Signed</span>   <span class="o">&lt;:</span> <span class="n">Integer</span>
<span class="k">abstract</span><span class="nc"> Unsigned</span> <span class="o">&lt;:</span> <span class="n">Integer</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">Number</span></tt> type is a direct child type of <tt class="docutils literal"><span class="pre">Any</span></tt>, and <tt class="docutils literal"><span class="pre">Real</span></tt> is
its child. In turn, <tt class="docutils literal"><span class="pre">Real</span></tt> has two children (it has more, but only two
are shown here; we&#8217;ll get to the others later): <tt class="docutils literal"><span class="pre">Integer</span></tt> and
<tt class="docutils literal"><span class="pre">FloatingPoint</span></tt>, separating the world into representations of integers and
representations of real numbers. Representations of real numbers
include, of course, floating-point types, but also include other types,
such as Julia&#8217;s rationals. Hence, <tt class="docutils literal"><span class="pre">FloatingPoint</span></tt> is a proper subtype of
<tt class="docutils literal"><span class="pre">Real</span></tt>, including only floating-point representations of real numbers.
Integers are further subdivided into <tt class="docutils literal"><span class="pre">Signed</span></tt> and <tt class="docutils literal"><span class="pre">Unsigned</span></tt>
varieties.</p>
<p>The <tt class="docutils literal"><span class="pre">&lt;:</span></tt> operator in general means &#8220;is a subtype of&#8221;, and, used in
declarations like this, declares the right-hand type to be an immediate
supertype of the newly declared type. It can also be used in expressions
as a subtype operator which returns <tt class="docutils literal"><span class="pre">true</span></tt> when its left operand is a
subtype of its right operand:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Integer</span> <span class="o">&lt;:</span> <span class="n">Number</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Integer</span> <span class="o">&lt;:</span> <span class="n">FloatingPoint</span>
<span class="n">false</span>
</pre></div>
</div>
<p>Since abstract types have no instantiations and serve as no more than
nodes in the type graph, there is not much more to say about them until
we introduce parametric abstract types later on in <a class="reference external" href="#man-parametric-types">Parametric
Types</a>.</p>
</div>
<div class="section" id="id1">
<h2>Bits Types<a class="headerlink" href="#id1" title="Enlazar permanentemente con este título">¶</a></h2>
<p>A bits type is a concrete type whose data consists of plain old bits.
Classic examples of bits types are integers and floating-point values.
Unlike most languages, Julia lets you declare your own bits types,
rather than providing only a fixed set of built-in bits types. In fact,
the standard bits types are all defined in the language itself:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">bitstype</span> <span class="mi">32</span> <span class="kt">Float32</span> <span class="o">&lt;:</span> <span class="n">FloatingPoint</span>
<span class="k">bitstype</span> <span class="mi">64</span> <span class="kt">Float64</span> <span class="o">&lt;:</span> <span class="n">FloatingPoint</span>

<span class="k">bitstype</span> <span class="mi">8</span>  <span class="kt">Bool</span> <span class="o">&lt;:</span> <span class="n">Integer</span>
<span class="k">bitstype</span> <span class="mi">32</span> <span class="n">Char</span> <span class="o">&lt;:</span> <span class="n">Integer</span>

<span class="k">bitstype</span> <span class="mi">8</span>  <span class="kt">Int8</span>   <span class="o">&lt;:</span> <span class="n">Signed</span>
<span class="k">bitstype</span> <span class="mi">8</span>  <span class="kt">Uint8</span>  <span class="o">&lt;:</span> <span class="n">Unsigned</span>
<span class="k">bitstype</span> <span class="mi">16</span> <span class="kt">Int16</span>  <span class="o">&lt;:</span> <span class="n">Signed</span>
<span class="k">bitstype</span> <span class="mi">16</span> <span class="kt">Uint16</span> <span class="o">&lt;:</span> <span class="n">Unsigned</span>
<span class="k">bitstype</span> <span class="mi">32</span> <span class="kt">Int32</span>  <span class="o">&lt;:</span> <span class="n">Signed</span>
<span class="k">bitstype</span> <span class="mi">32</span> <span class="kt">Uint32</span> <span class="o">&lt;:</span> <span class="n">Unsigned</span>
<span class="k">bitstype</span> <span class="mi">64</span> <span class="kt">Int64</span>  <span class="o">&lt;:</span> <span class="n">Signed</span>
<span class="k">bitstype</span> <span class="mi">64</span> <span class="kt">Uint64</span> <span class="o">&lt;:</span> <span class="n">Unsigned</span>
</pre></div>
</div>
<p>The general syntaxes for declaration of a bitstypes are:</p>
<div class="highlight-julia"><div class="highlight"><pre>bitstype «bits» «name»
bitstype «bits» «name» &lt;: «supertype»
</pre></div>
</div>
<p>The number of bits indicates how much storage the type requires and the
name gives the new type a name. A bits type can optionally be declared
to be a subtype of some supertype. If a supertype is omitted, then the
type defaults to having <tt class="docutils literal"><span class="pre">Any</span></tt> as its immediate supertype. The
declaration of <tt class="docutils literal"><span class="pre">Bool</span></tt> above therefore means that a boolean value takes
eight bits to store, and has <tt class="docutils literal"><span class="pre">Integer</span></tt> as its immediate supertype.
Currently, only sizes that are multiples of 8 bits are supported.
Therefore, boolean values, although they really need just a single bit,
cannot be declared to be any smaller than eight bits.</p>
<p>The types <tt class="docutils literal"><span class="pre">Bool</span></tt>, <tt class="docutils literal"><span class="pre">Int8</span></tt> and <tt class="docutils literal"><span class="pre">Uint8</span></tt> all have identical
representations: they are eight-bit chunks of memory. Since Julia&#8217;s type
system is nominative, however, they are not interchangeable despite
having identical structure. Another fundamental difference between them
is that they have different supertypes: <tt class="docutils literal"><span class="pre">Bool</span></tt>&#8216;s direct supertype is
<tt class="docutils literal"><span class="pre">Integer</span></tt>, <tt class="docutils literal"><span class="pre">Int8</span></tt>&#8216;s is <tt class="docutils literal"><span class="pre">Signed</span></tt>, and <tt class="docutils literal"><span class="pre">Uint8</span></tt>&#8216;s is <tt class="docutils literal"><span class="pre">Unsigned</span></tt>.
All other differences between <tt class="docutils literal"><span class="pre">Bool</span></tt>, <tt class="docutils literal"><span class="pre">Int8</span></tt>, and <tt class="docutils literal"><span class="pre">Uint8</span></tt> are
matters of behavior — the way functions are defined to act when given
objects of these types as arguments. This is why a nominative type
system is necessary: if structure determined type, which in turn
dictates behavior, then it would be impossible to make <tt class="docutils literal"><span class="pre">Bool</span></tt> behave any
differently than <tt class="docutils literal"><span class="pre">Int8</span></tt> or <tt class="docutils literal"><span class="pre">Uint8</span></tt>.</p>
</div>
<div class="section" id="composite-types">
<span id="man-composite-types"></span><h2>Composite Types<a class="headerlink" href="#composite-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Composite_data_type">Composite types</a>
are called records, structures (&#8220;structs&#8221; in C), or objects in various
languages. A composite type is a collection of named fields, an instance
of which can be treated as a single value. In many languages, composite
types are the only kind of user-definable type, and they are by far the
most commonly used user-defined type in Julia as well. In mainstream
object oriented languages, such as C++, Java, Python and Ruby, composite
types also have named functions associated with them, and the
combination is called an &#8220;object&#8221;. In purer object-oriented languages,
such as Python and Ruby, all values are objects whether they are
composites or not. In less pure object oriented languages, including C++
and Java, some values, such as integers and floating-point values, are
not objects, while instances of user-defined composite types are true
objects with associated methods. In Julia, all values are objects, as in
Python and Ruby, but functions are not bundled with the objects they
operate on. This is necessary since Julia chooses which method of a
function to use by multiple dispatch, meaning that the types of <em>all</em> of
a function&#8217;s arguments are considered when selecting a method, rather
than just the first one (see <a class="reference internal" href="methods.html#man-methods"><em>Methods</em></a> for more
information on methods and dispatch). Thus, it would be inappropriate
for functions to &#8220;belong&#8221; to only their first argument. Organizing
methods by association with function objects rather than simply having
named bags of methods &#8220;inside&#8221; each object ends up being a highly
beneficial aspect of the language design.</p>
<p>Since composite types are the most common form of user-defined concrete
type, they are simply introduced with the <tt class="docutils literal"><span class="pre">type</span></tt> keyword followed by a
block of field names, optionally annotated with types using the <tt class="docutils literal"><span class="pre">::</span></tt>
operator:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Foo</span>
  <span class="n">bar</span>
  <span class="n">baz</span><span class="p">::</span><span class="kt">Int</span>
  <span class="n">qux</span><span class="p">::</span><span class="kt">Float64</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Fields with no type annotation default to <tt class="docutils literal"><span class="pre">Any</span></tt>, and can accordingly
hold any type of value.</p>
<p>New objects of composite type <tt class="docutils literal"><span class="pre">Foo</span></tt> are created by applying the
<tt class="docutils literal"><span class="pre">Foo</span></tt> type object like a function to values for its fields:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="s">&quot;Hello, world.&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="s">&quot;Hello, world.&quot;</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">Foo</span>
</pre></div>
</div>
<p>Since the <tt class="docutils literal"><span class="pre">bar</span></tt> field is unconstrained in type, any value will do; the
value for <tt class="docutils literal"><span class="pre">baz</span></tt> must be an <tt class="docutils literal"><span class="pre">Int</span></tt> and <tt class="docutils literal"><span class="pre">qux</span></tt> must be a <tt class="docutils literal"><span class="pre">Float64</span></tt>.
The signature of the default constructor is taken directly from the
field type declarations <tt class="docutils literal"><span class="pre">(Any,Int,Float64)</span></tt>, so arguments must match
this implied type signature:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Foo</span><span class="p">((),</span> <span class="mf">23.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">Foo</span><span class="p">((),</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">)</span>
</pre></div>
</div>
<p>You can access the field values of a composite object using the
traditional <tt class="docutils literal"><span class="pre">foo.bar</span></tt> notation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">bar</span>
<span class="s">&quot;Hello, world.&quot;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">baz</span>
<span class="mi">23</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">qux</span>
<span class="mf">1.5</span>
</pre></div>
</div>
<p>You can also change the values as one would expect:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">qux</span> <span class="o">=</span> <span class="mi">2</span>
<span class="mf">2.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">1</span><span class="o">//</span><span class="mi">2</span>
<span class="mi">1</span><span class="o">//</span><span class="mi">2</span>
</pre></div>
</div>
<p>Composite types with no fields are singletons; there can be only one
instance of such types:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> NoFields</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">is</span><span class="p">(</span><span class="n">NoFields</span><span class="p">(),</span> <span class="n">NoFields</span><span class="p">())</span>
<span class="n">true</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">is</span></tt> function confirms that the &#8220;two&#8221; constructed instances of
<tt class="docutils literal"><span class="pre">NoFields</span></tt> are actually one and the same.</p>
<p>There is much more to say about how instances of composite types are
created, but that discussion depends on both <a class="reference external" href="#man-parametric-types">Parametric
Types</a> and on <a class="reference internal" href="methods.html#man-methods"><em>Methods</em></a>, and is
sufficiently important to be addressed in its own section:
<a class="reference internal" href="constructors.html#man-constructors"><em>Constructors</em></a>.</p>
</div>
<div class="section" id="type-unions">
<h2>Type Unions<a class="headerlink" href="#type-unions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>A type union is a special abstract type which includes as objects all
instances of any of its argument types, constructed using the special
<tt class="docutils literal"><span class="pre">Union</span></tt> function:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">IntOrString</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="n">String</span><span class="p">)</span>
<span class="n">Union</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="n">String</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="p">::</span> <span class="n">IntOrString</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="s">&quot;Hello!&quot;</span> <span class="p">::</span> <span class="n">IntOrString</span>
<span class="s">&quot;Hello!&quot;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">1.0</span> <span class="p">::</span> <span class="n">IntOrString</span>
<span class="k">type</span><span class="nc"> error</span><span class="p">:</span> <span class="n">typeassert</span><span class="p">:</span> <span class="n">expected</span> <span class="n">Union</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="n">String</span><span class="p">),</span> <span class="n">got</span> <span class="kt">Float64</span>
</pre></div>
</div>
<p>The compilers for many languages have an internal union construct for
reasoning about types; Julia simply exposes it to the programmer. The
union of no types is the &#8220;bottom&#8221; type, <tt class="docutils literal"><span class="pre">None</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Union</span><span class="p">()</span>
<span class="kt">None</span>
</pre></div>
</div>
<p>Recall from the <a class="reference external" href="#Any+and+None">discussion above</a> that <tt class="docutils literal"><span class="pre">None</span></tt> is the
abstract type which is the subtype of all other types, and which no
object is an instance of. Since a zero-argument <tt class="docutils literal"><span class="pre">Union</span></tt> call has no
argument types for objects to be instances of, it should produce a
type which no objects are instances of —&nbsp;i.e. <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</div>
<div class="section" id="tuple-types">
<h2>Tuple Types<a class="headerlink" href="#tuple-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Tuples are an abstraction of the arguments of a function —&nbsp;without the
function itself. The salient aspects of a function&#8217;s arguments are their
order and their types. The type of a tuple of values is the tuple of
types of values:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">))</span>
<span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="n">ASCIIString</span><span class="p">,</span><span class="kt">Float64</span><span class="p">)</span>
</pre></div>
</div>
<p>Accordingly, a tuple of types can be used anywhere a type is expected:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span> <span class="p">::</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="n">String</span><span class="p">,</span><span class="kt">Any</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span> <span class="p">::</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="n">String</span><span class="p">,</span><span class="kt">Float32</span><span class="p">)</span>
<span class="k">type</span><span class="nc"> error</span><span class="p">:</span> <span class="n">typeassert</span><span class="p">:</span> <span class="n">expected</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="n">String</span><span class="p">,</span><span class="kt">Float32</span><span class="p">),</span> <span class="n">got</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="n">ASCIIString</span><span class="p">,</span><span class="kt">Float64</span><span class="p">)</span>
</pre></div>
</div>
<p>If one of the components of the tuple is not a type, however, you will
get an error:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span> <span class="p">::</span> <span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="n">String</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="k">type</span><span class="nc"> error</span><span class="p">:</span> <span class="n">typeassert</span><span class="p">:</span> <span class="n">expected</span> <span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">},</span> <span class="n">got</span> <span class="p">(</span><span class="n">BitsKind</span><span class="p">,</span><span class="n">AbstractKind</span><span class="p">,</span><span class="kt">Int64</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the empty tuple <tt class="docutils literal"><span class="pre">()</span></tt> is its own type:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(())</span>
<span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="man-parametric-types">
<span id="id4"></span><h2>Parametric Types<a class="headerlink" href="#man-parametric-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p>An important and powerful feature of Julia&#8217;s type system is that it is
parametric: types can take parameters, so that type declarations
actually introduce a whole family of new types — one for each possible
combination of parameter values. There are many languages that support
some version of <a class="reference external" href="http://en.wikipedia.org/wiki/Generic_programming">generic
programming</a>,&nbsp;wherein
data structures and algorithms to manipulate them may be specified
without specifying the exact types involved. For example, some form of
generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#,
F#, and Scala, just to name a few. Some of these languages support true
parametric polymorphism (e.g. ML, Haskell, Scala), while others support
ad-hoc, template-based styles of generic programming (e.g. C++, Java).
With so many different varieties of generic programming and parametric
types in various languages, we won&#8217;t even attempt to compare Julia&#8217;s
parametric types to other languages, but will instead focus on
explaining Julia&#8217;s system in its own right. We will note, however, that
because Julia is a dynamically typed language and doesn&#8217;t need to make
all type decisions at compile time, many traditional difficulties
encountered in static parametric type systems can be relatively easily
handled.</p>
<p>The only kinds of types that are declared are abstract types, bits
types, and composite types. All such types can be parameterized, with
the same syntax in each case. We will discuss them in in the following
order: first, parametric composite types, then parametric abstract
types, and finally parametric bits types.</p>
<div class="section" id="parametric-composite-types">
<h3>Parametric Composite Types<a class="headerlink" href="#parametric-composite-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Type parameters are introduced immediately after the type name,
surrounded by curly braces:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
  <span class="n">x</span><span class="p">::</span><span class="n">T</span>
  <span class="n">y</span><span class="p">::</span><span class="n">T</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This declaration defines a new parametric type, <tt class="docutils literal"><span class="pre">Point{T}</span></tt>, holding
two &#8220;coordinates&#8221; of type <tt class="docutils literal"><span class="pre">T</span></tt>. What, one may ask, is <tt class="docutils literal"><span class="pre">T</span></tt>? Well,
that&#8217;s precisely the point of parametric types: it can be any type at
all (or an integer, actually, although here it&#8217;s clearly used as a
type). <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt> is a concrete type equivalent to the type
defined by replacing <tt class="docutils literal"><span class="pre">T</span></tt> in the definition of <tt class="docutils literal"><span class="pre">Point</span></tt> with
<tt class="docutils literal"><span class="pre">Float64</span></tt>. Thus, this single declaration actually declares an
unlimited number of types: <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt>, <tt class="docutils literal"><span class="pre">Point{String}</span></tt>,
<tt class="docutils literal"><span class="pre">Point{Int64}</span></tt>, etc. Each of these is now a usable concrete type:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="n">String</span><span class="p">}</span>
<span class="n">Point</span><span class="p">{</span><span class="n">String</span><span class="p">}</span>
</pre></div>
</div>
<p>The type <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt> is a point whose coordinates are 64-bit
floating-point values, while the type <tt class="docutils literal"><span class="pre">Point{String}</span></tt> is a &#8220;point&#8221;
whose &#8220;coordinates&#8221; are string objects (see <a class="reference internal" href="strings.html#man-strings"><em>Strings</em></a>).
However, <tt class="docutils literal"><span class="pre">Point</span></tt> itself is also a valid type object:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span>
<span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
</pre></div>
</div>
<p>Here the <tt class="docutils literal"><span class="pre">T</span></tt> is the dummy type symbol used in the original declaration
of <tt class="docutils literal"><span class="pre">Point</span></tt>. What does <tt class="docutils literal"><span class="pre">Point</span></tt> by itself mean? It is an abstract type
that contains all the specific instances <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt>,
<tt class="docutils literal"><span class="pre">Point{String}</span></tt>, etc.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Point</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="n">String</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Point</span>
<span class="n">true</span>
</pre></div>
</div>
<p>Other types, of course, are not subtypes of it:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Float64</span> <span class="o">&lt;:</span> <span class="n">Point</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">String</span> <span class="o">&lt;:</span> <span class="n">Point</span>
<span class="n">false</span>
</pre></div>
</div>
<p>Concrete <tt class="docutils literal"><span class="pre">Point</span></tt> types with different values of <tt class="docutils literal"><span class="pre">T</span></tt> are never
subtypes of each other:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Point</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span>
<span class="n">false</span>
</pre></div>
</div>
<p>This last point is very important:</p>
<blockquote>
<div><strong>Even though ``Float64 &lt;: Real`` we DO NOT have
``Point{Float64} &lt;: Point{Real}``.</strong></div></blockquote>
<p>In other words, in the parlance of type theory, Julia&#8217;s type parameters
are <em>invariant</em>, rather than being covariant (or even contravariant).
This is for practical reasons: while any instance of <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt>
may conceptually be like an instance of <tt class="docutils literal"><span class="pre">Point{Real}</span></tt> as well, the two
types have different representations in memory:</p>
<ul class="simple">
<li>An instance of <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt> can be represented compactly and
efficiently as an immediate pair of 64-bit values;</li>
<li>An instance of <tt class="docutils literal"><span class="pre">Point{Real}</span></tt> must be able to hold any pair of
instances of <tt class="docutils literal"><span class="pre">Real</span></tt>. Since objects that are instances of <tt class="docutils literal"><span class="pre">Real</span></tt>
can be of arbitrary size and structure, in practice an instance of
<tt class="docutils literal"><span class="pre">Point{Real}</span></tt> must be represented as a pair of pointers to
individually allocated <tt class="docutils literal"><span class="pre">Real</span></tt> objects.</li>
</ul>
<p>The efficiency gained by being able to store <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt> objects
with immediate values is magnified enormously in the case of arrays: an
<tt class="docutils literal"><span class="pre">Array{Float64}</span></tt> can be stored as a contiguous memory block of 64-bit
floating-point values, whereas an <tt class="docutils literal"><span class="pre">Array{Real}</span></tt> must be an array of
pointers to individually allocated <tt class="docutils literal"><span class="pre">Real</span></tt> objects —&nbsp;which may well be
<a class="reference external" href="http://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing">boxed</a>
64-bit floating-point values, but also might be arbitrarily large,
complex objects, which are declared to be implementations of the
<tt class="docutils literal"><span class="pre">Real</span></tt> abstract type.</p>
<p>How does one construct a <tt class="docutils literal"><span class="pre">Point</span></tt> object? It is possible to define
custom constructors for composite types, which will be discussed in
detail in <a class="reference internal" href="constructors.html#man-constructors"><em>Constructors</em></a>, but in the absence of any
special constructor declarations, there are two default ways of creating
new composite objects, one in which the type parameters are explicitly
given and the other in which they are implied by the arguments to the
object constructor.</p>
<p>Since the type <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt> is a concrete type equivalent to
<tt class="docutils literal"><span class="pre">Point</span></tt> declared with <tt class="docutils literal"><span class="pre">Float64</span></tt> in place of <tt class="docutils literal"><span class="pre">T</span></tt>, it can be applied
as a constructor accordingly:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>
</pre></div>
</div>
<p>For the default constructor, exactly one argument must be supplied for
each field:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">Point</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">Point</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">Float64</span><span class="p">)</span>
</pre></div>
</div>
<p>The provided arguments need to match the field types exactly, in this
case <tt class="docutils literal"><span class="pre">(Float64,Float64)</span></tt>, as with all composite type default
constructors.</p>
<p>In many cases, it is redundant to provide the type of <tt class="docutils literal"><span class="pre">Point</span></tt> object
one wants to construct, since the types of arguments to the constructor
call already implicitly provide type information. For that reason, you
can also apply <tt class="docutils literal"><span class="pre">Point</span></tt> itself as a constructor, provided that the
implied value of the parameter type <tt class="docutils literal"><span class="pre">T</span></tt> is unambiguous:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span>
</pre></div>
</div>
<p>In the case of <tt class="docutils literal"><span class="pre">Point</span></tt>, the type of <tt class="docutils literal"><span class="pre">T</span></tt> is unambiguously implied if
and only if the two arguments to <tt class="docutils literal"><span class="pre">Point</span></tt> have the same type. When this
isn&#8217;t the case, the constructor will fail with a no method error:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">Point</span><span class="p">(</span><span class="kt">Int64</span><span class="p">,</span><span class="kt">Float64</span><span class="p">)</span>
</pre></div>
</div>
<p>Constructor methods to appropriately handle such mixed cases can be
defined, but that will not be discussed until later on in
<a class="reference internal" href="constructors.html#man-constructors"><em>Constructors</em></a>.</p>
</div>
<div class="section" id="parametric-abstract-types">
<h3>Parametric Abstract Types<a class="headerlink" href="#parametric-abstract-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Parametric abstract type declarations declare a collection of abstract
types, in much the same way:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">abstract</span><span class="nc"> Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
</pre></div>
</div>
<p>With this declaration, <tt class="docutils literal"><span class="pre">Pointy{T}</span></tt> is a distinct abstract type for
each type or integer value of <tt class="docutils literal"><span class="pre">T</span></tt>. As with parametric composite types,
each such instance is a subtype of <tt class="docutils literal"><span class="pre">Pointy</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span>
<span class="n">true</span>
</pre></div>
</div>
<p>Parametric abstract types are invariant, much as parametric composite
types are:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>
<span class="n">false</span>
</pre></div>
</div>
<p>Much as plain old abstract types serve to create a useful hierarchy of
types over concrete types, parametric abstract types serve the same
purpose with respect to parametric composite types. We could, for
example, have declared <tt class="docutils literal"><span class="pre">Point{T}</span></tt> to be a subtype of <tt class="docutils literal"><span class="pre">Pointy{T}</span></tt> as
follows:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
  <span class="n">x</span><span class="p">::</span><span class="n">T</span>
  <span class="n">y</span><span class="p">::</span><span class="n">T</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Given such a declaration, for each choice of <tt class="docutils literal"><span class="pre">T</span></tt>, we have <tt class="docutils literal"><span class="pre">Point{T}</span></tt>
as a subtype of <tt class="docutils literal"><span class="pre">Pointy{T}</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="n">String</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">String</span><span class="p">}</span>
<span class="n">true</span>
</pre></div>
</div>
<p>This relationship is also invariant:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span>
<span class="n">false</span>
</pre></div>
</div>
<p>What purpose do parametric abstract types like <tt class="docutils literal"><span class="pre">Pointy</span></tt> serve?
Consider if we create a point-like implementation that only requires a
single coordinate because the point is on the diagonal line <em>x = y</em>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> DiagPoint</span><span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
  <span class="n">x</span><span class="p">::</span><span class="n">T</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Now both <tt class="docutils literal"><span class="pre">Point{Float64}</span></tt> and <tt class="docutils literal"><span class="pre">DiagPoint{Float64}</span></tt> are
implementations of the <tt class="docutils literal"><span class="pre">Pointy{Float64}</span></tt> abstraction, and similarly
for every other possible choice of type <tt class="docutils literal"><span class="pre">T</span></tt>. This allows programming
to a common interface shared by all <tt class="docutils literal"><span class="pre">Pointy</span></tt> objects, implemented for
both <tt class="docutils literal"><span class="pre">Point</span></tt> and <tt class="docutils literal"><span class="pre">DiagPoint</span></tt>. This cannot be fully demonstrated,
however, until we have introduced methods and dispatch in the next
section, <a class="reference internal" href="methods.html#man-methods"><em>Methods</em></a>.</p>
<p>There are situations where it may not make sense for type parameters to
range freely over all possible types. In such situations, one can
constrain the range of <tt class="docutils literal"><span class="pre">T</span></tt> like so:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">abstract</span><span class="nc"> Pointy</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span>
</pre></div>
</div>
<p>With such a declaration, it is acceptable to use any type that is a
subtype of <tt class="docutils literal"><span class="pre">Real</span></tt> in place of <tt class="docutils literal"><span class="pre">T</span></tt>, but not types that are not
subtypes of <tt class="docutils literal"><span class="pre">Real</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>
<span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span>
<span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">String</span><span class="p">}</span>
<span class="k">type</span><span class="nc"> error</span><span class="p">:</span> <span class="n">Pointy</span><span class="p">:</span> <span class="k">in</span> <span class="n">T</span><span class="p">,</span> <span class="n">expected</span> <span class="n">Real</span><span class="p">,</span> <span class="n">got</span> <span class="n">AbstractKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Pointy</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="k">type</span><span class="nc"> error</span><span class="p">:</span> <span class="n">Pointy</span><span class="p">:</span> <span class="k">in</span> <span class="n">T</span><span class="p">,</span> <span class="n">expected</span> <span class="n">Real</span><span class="p">,</span> <span class="n">got</span> <span class="kt">Int64</span>
</pre></div>
</div>
<p>Type parameters for parametric composite types can be restricted in the
same manner:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
  <span class="n">x</span><span class="p">::</span><span class="n">T</span>
  <span class="n">y</span><span class="p">::</span><span class="n">T</span>
<span class="k">end</span>
</pre></div>
</div>
<p>To give a couple of real-world examples of how all this parametric type
machinery can be useful, here is the actual definition of Julia&#8217;s
<tt class="docutils literal"><span class="pre">Rational</span></tt> type, representing an exact ratio of integers:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Rational</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Real</span>
  <span class="n">num</span><span class="p">::</span><span class="n">T</span>
  <span class="n">den</span><span class="p">::</span><span class="n">T</span>
<span class="k">end</span>
</pre></div>
</div>
<p>It only makes sense to take ratios of integer values, so the parameter
type <tt class="docutils literal"><span class="pre">T</span></tt> is restricted to being a subtype of <tt class="docutils literal"><span class="pre">Integer</span></tt>, and a ratio
of integers represents a value on the real number line, so any
<tt class="docutils literal"><span class="pre">Rational</span></tt> is an instance of the <tt class="docutils literal"><span class="pre">Real</span></tt> abstraction.</p>
<div class="section" id="singleton-types">
<span id="man-singleton-types"></span><h4>Singleton Types<a class="headerlink" href="#singleton-types" title="Enlazar permanentemente con este título">¶</a></h4>
<p>There is a special kind of abstract parametric type that must be
mentioned here: singleton types. For each type, <tt class="docutils literal"><span class="pre">T</span></tt>, the &#8220;singleton
type&#8221; <tt class="docutils literal"><span class="pre">Type{T}</span></tt> is an abstract type whose only instance is the object
<tt class="docutils literal"><span class="pre">T</span></tt>. Since the definition is a little difficult to parse, let&#8217;s look
at some examples:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">})</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">})</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">Type</span><span class="p">{</span><span class="n">Real</span><span class="p">})</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">Type</span><span class="p">{</span><span class="n">Real</span><span class="p">})</span>
<span class="n">false</span>
</pre></div>
</div>
<p>In other words, <tt class="docutils literal"><span class="pre">isa(A,Type{B})</span></tt> is true if and only if <tt class="docutils literal"><span class="pre">A</span></tt> and
<tt class="docutils literal"><span class="pre">B</span></tt> are the same object and that object is a type. Without the
parameter, <tt class="docutils literal"><span class="pre">Type</span></tt> is simply an abstract type which has all type
objects as its instances, including, of course, singleton types:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span><span class="n">Type</span><span class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span>
<span class="n">true</span>
</pre></div>
</div>
<p>Any object that is not a type is not an instance of <tt class="docutils literal"><span class="pre">Type</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span>
<span class="n">false</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span>
<span class="n">false</span>
</pre></div>
</div>
<p>Until we discuss <a class="reference internal" href="methods.html#man-parametric-methods"><em>Parametric Methods</em></a>
and <a class="reference internal" href="conversion-and-promotion.html#man-conversion"><em>conversions</em></a>, it is
difficult to explain the utility of the singleton type construct, but in
short, it allows one to specialize function behavior on specific type
<em>values</em>, rather just kinds of types, which is all that would be
possible in the absence of singleton types. This is useful for writing
methods (especially parametric ones) whose behavior depends on a type
that is given as an explicit argument rather than implied by the type of
one of its arguments.</p>
<p>A few popular languages have singleton types, including Haskell, Scala
and Ruby. In general usage, the term &#8220;singleton type&#8221; refers to a type
whose only instance is a single value. This meaning applies to Julia&#8217;s
singleton types, but with that caveat that only type objects have
singleton types, whereas in most languages with singleton types, every
object has one.</p>
</div>
</div>
<div class="section" id="parametric-bits-types">
<h3>Parametric Bits Types<a class="headerlink" href="#parametric-bits-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Bits types can also be declared parametrically. For example, pointers
are represented as boxed bits types which would be declared in Julia
like this:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># 32-bit system:</span>
<span class="k">bitstype</span> <span class="mi">32</span> <span class="n">Ptr</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>

<span class="c"># 64-bit system:</span>
<span class="k">bitstype</span> <span class="mi">64</span> <span class="n">Ptr</span><span class="p">{</span><span class="n">T</span><span class="p">}</span>
</pre></div>
</div>
<p>The slightly odd feature of these declarations as compared to typical
parametric composite types, is that the type parameter <tt class="docutils literal"><span class="pre">T</span></tt> is not used
in the definition of the type itself —&nbsp;it is just an abstract tag,
essentially defining an entire family of types with identical structure,
differentiated only by their type parameter. Thus, <tt class="docutils literal"><span class="pre">Ptr{Float64}</span></tt> and
<tt class="docutils literal"><span class="pre">Ptr{Int64}</span></tt> are distinct types, even though they have identical
representations. And of course, all specific pointer types are subtype
of the umbrella <tt class="docutils literal"><span class="pre">Ptr</span></tt> type:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Ptr</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Ptr</span>
<span class="n">true</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-aliases">
<h2>Type Aliases<a class="headerlink" href="#type-aliases" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Sometimes it is convenient to introduce a new name for an already
expressible type. For such occasions, Julia provides the <tt class="docutils literal"><span class="pre">typealias</span></tt>
mechanism. For example, <tt class="docutils literal"><span class="pre">Uint</span></tt> is type aliased to either <tt class="docutils literal"><span class="pre">Uint32</span></tt> or
<tt class="docutils literal"><span class="pre">Uint64</span></tt> as is appropriate for the size of pointers on the system:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># 32-bit system:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Uint</span>
<span class="kt">Uint32</span>

<span class="c"># 64-bit system:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Uint</span>
<span class="kt">Uint64</span>
</pre></div>
</div>
<p>This is accomplished via the following code in <tt class="docutils literal"><span class="pre">base/boot.jl</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">if</span> <span class="nb">is</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int64</span><span class="p">)</span>
    <span class="k">typealias</span><span class="nc"> Uint</span> <span class="kt">Uint64</span>
<span class="k">else</span>
    <span class="k">typealias</span><span class="nc"> Uint</span> <span class="kt">Uint32</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Of course, this depends on what <tt class="docutils literal"><span class="pre">Int</span></tt> is aliased to —&nbsp;but that is
pre-defined to be the correct type —&nbsp;either <tt class="docutils literal"><span class="pre">Int32</span></tt> or <tt class="docutils literal"><span class="pre">Int64</span></tt>.</p>
<p>For parametric types, <tt class="docutils literal"><span class="pre">typealias</span></tt> can be convenient for providing a
new parametric types name where one of the parameter choices is fixed.
Julia&#8217;s arrays have type <tt class="docutils literal"><span class="pre">Array{T,n}</span></tt> where <tt class="docutils literal"><span class="pre">T</span></tt> is the element type
and <tt class="docutils literal"><span class="pre">n</span></tt> is the number of array dimensions. For convenience, writing
<tt class="docutils literal"><span class="pre">Array{Float64}</span></tt> allows one to specify the element type without
specifying the dimension:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span> <span class="o">&lt;:</span> <span class="n">Array</span>
<span class="n">true</span>
</pre></div>
</div>
<p>However, there is no way to equally simply restrict just the dimension
but not the element type. Yet, one often needs to ensure an object
is a vector or a matrix (imposing restrictions on the number of dimensions). For
that reason, the following type aliases are provided:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">typealias</span><span class="nc"> Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
<span class="k">typealias</span><span class="nc"> Matrix</span><span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span>
</pre></div>
</div>
<p>Writing <tt class="docutils literal"><span class="pre">Vector{Float64}</span></tt> is equivalent to writing
<tt class="docutils literal"><span class="pre">Array{Float64,1}</span></tt>, and the umbrella type <tt class="docutils literal"><span class="pre">Vector</span></tt> has as instances
all <tt class="docutils literal"><span class="pre">Array</span></tt> objects where the second parameter —&nbsp;the number of array
dimensions —&nbsp;is 1, regardless of what the element type is. In languages
where parametric types must be always specified in full, this is not
especially helpful, but in Julia, this allows one to write just
<tt class="docutils literal"><span class="pre">Matrix</span></tt> for the abstract type including all two-dimensional dense
arrays of any element type.</p>
</div>
<div class="section" id="operations-on-types">
<h2>Operations on Types<a class="headerlink" href="#operations-on-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Since types in Julia are themselves objects, ordinary functions can
operate on them. Some functions that are particularly useful for working
with or exploring types have already been introduced, such as the <tt class="docutils literal"><span class="pre">&lt;:</span></tt>
operator, which indicates whether its left hand operand is a subtype of
its right hand operand.</p>
<p>The <tt class="docutils literal"><span class="pre">isa</span></tt> function tests if an object is of a given type and returns
true or false:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">isa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">FloatingPoint</span><span class="p">)</span>
<span class="n">false</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">typeof</span></tt> function, already used throughout the manual in examples,
returns the type of its argument. Since, as noted above, types are
objects, they also have types, and we can ask what their types are. Here
we apply <tt class="docutils literal"><span class="pre">typeof</span></tt> to an instance of each of the kinds of types
discussed above:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">Real</span><span class="p">)</span>
<span class="n">AbstractKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span>
<span class="n">BitsKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">Rational</span><span class="p">)</span>
<span class="n">CompositeKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">Union</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span><span class="kt">Float64</span><span class="p">,</span><span class="n">Rational</span><span class="p">))</span>
<span class="n">UnionKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">((</span><span class="n">Real</span><span class="p">,</span><span class="kt">Float64</span><span class="p">,</span><span class="n">Rational</span><span class="p">,</span><span class="kt">None</span><span class="p">))</span>
<span class="p">(</span><span class="n">AbstractKind</span><span class="p">,</span><span class="n">BitsKind</span><span class="p">,</span><span class="n">CompositeKind</span><span class="p">,</span><span class="n">UnionKind</span><span class="p">)</span>
</pre></div>
</div>
<p>As you can see, the types of types are called, by convention, &#8220;kinds&#8221;:</p>
<ul class="simple">
<li>Abstract types have type <tt class="docutils literal"><span class="pre">AbstractKind</span></tt></li>
<li>Bits types have type <tt class="docutils literal"><span class="pre">BitsKind</span></tt></li>
<li>Composite types have type <tt class="docutils literal"><span class="pre">CompositeKind</span></tt></li>
<li>Unions have type <tt class="docutils literal"><span class="pre">UnionKind</span></tt></li>
<li>Tuples of types have a type that is the tuple of their respective
kinds.</li>
</ul>
<p>What if we repeat the process? What is the type of a kind? Kinds, as it
happens, are all composite values and thus all have a type of
<tt class="docutils literal"><span class="pre">CompositeKind</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">AbstractKind</span><span class="p">)</span>
<span class="n">CompositeKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">BitsKind</span><span class="p">)</span>
<span class="n">CompositeKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">CompositeKind</span><span class="p">)</span>
<span class="n">CompositeKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">UnionKind</span><span class="p">)</span>
<span class="n">CompositeKind</span>
</pre></div>
</div>
<p>The reader may note that <tt class="docutils literal"><span class="pre">CompositeKind</span></tt> shares with the empty tuple
(see <a class="reference external" href="#tuple-types">above</a>), the distinction of being its own type
(i.e. a fixed point of the <tt class="docutils literal"><span class="pre">typeof</span></tt> function). This leads any number
of tuple types recursively built with <tt class="docutils literal"><span class="pre">()</span></tt> and <tt class="docutils literal"><span class="pre">CompositeKind</span></tt> as
their only atomic values, which are their own type:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(())</span>
<span class="p">()</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">CompositeKind</span><span class="p">)</span>
<span class="n">CompositeKind</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(((),))</span>
<span class="p">((),)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">((</span><span class="n">CompositeKind</span><span class="p">,))</span>
<span class="p">(</span><span class="n">CompositeKind</span><span class="p">,)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(((),</span><span class="n">CompositeKind</span><span class="p">))</span>
<span class="p">((),</span><span class="n">CompositeKind</span><span class="p">)</span>
</pre></div>
</div>
<p>All fixed points of the <tt class="docutils literal"><span class="pre">typeof</span></tt> function are like this.</p>
<p>Another operation that applies to some kinds of types is <tt class="docutils literal"><span class="pre">super</span></tt>. Only
abstract types (<tt class="docutils literal"><span class="pre">AbstractKind</span></tt>), bits types (<tt class="docutils literal"><span class="pre">BitsKind</span></tt>), and
composite types (<tt class="docutils literal"><span class="pre">CompositeKind</span></tt>) have a supertype, so these are the
only kinds of types that the <tt class="docutils literal"><span class="pre">super</span></tt> function applies to:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span>
<span class="n">FloatingPoint</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span>
<span class="kt">Any</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="kt">Any</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span>
<span class="kt">Any</span>
</pre></div>
</div>
<p>If you apply <tt class="docutils literal"><span class="pre">super</span></tt> to other type objects (or non-type objects), a
&#8220;no method&#8221; error is raised:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">(</span><span class="n">Union</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">))</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">super</span><span class="p">(</span><span class="n">UnionKind</span><span class="p">,)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">(</span><span class="kt">None</span><span class="p">)</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">super</span><span class="p">(</span><span class="n">UnionKind</span><span class="p">,)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">super</span><span class="p">((</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">))</span>
<span class="n">no</span> <span class="n">method</span> <span class="n">super</span><span class="p">((</span><span class="n">BitsKind</span><span class="p">,</span><span class="n">BitsKind</span><span class="p">),)</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="methods.html" class="btn btn-neutral float-right" title="Methods">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="variables-and-scoping.html" class="btn btn-neutral" title="Variables and Scoping"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2013, Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al..
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.3-dev',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>